****************************
DQL: Doctrine Query Language
****************************

============
Introduction
============

Doctrine Query Language (DQL) is an Object Query Language created for
helping users in complex object retrieval. You should always consider
using DQL (or raw SQL) when retrieving relational data efficiently (eg.
when fetching users and their phonenumbers).

In this chapter we will execute dozens of examples of how to use the
Doctrine Query Language. All of these examples assume you are using the
schemas defined in the previous chapters, primarily the [doc
defining-models :name] chapter. We will define one additional model for
our testing purposes:

 // models/Account.php

class Account extends Doctrine\_Record { public function
setTableDefinition() { $this->hasColumn('name', 'string', 255);
$this->hasColumn('amount', 'decimal'); } }

Here is the same example in YAML format. You can read more about YAML in
the [doc yaml-schema-files :name] chapter:

 # schema.yml

...
===

Account: columns: name: string(255) amount: decimal

When compared to using raw SQL, DQL has several benefits:

-  From the start it has been designed to retrieve records(objects) not
   result set rows
-  DQL understands relations so you don't have to type manually sql
   joins and join conditions
-  DQL is portable on different databases
-  DQL has some very complex built-in algorithms like (the record limit
   algorithm) which can help the developer to efficiently retrieve
   objects
-  It supports some functions that can save time when dealing with
   one-to-many, many-to-many relational data with conditional fetching.

If the power of DQL isn't enough, you should consider using the [doc
native-sql RawSql API] for object population.

You may already be familiar with the following syntax:

.. CAUTION::

    DO NOT USE THE FOLLOWING CODE. It uses many sql queries
    for object population.

 // test.php

// ... $users = Doctrine\_Core::getTable('User')->findAll();

foreach($users as $user) { echo $user->username . " has phonenumbers: ";

::

    foreach($user->Phonenumbers as $phonenumber) {
        echo $phonenumber->phonenumber . "\n";
    }

}

.. tip::

    Here is the same code but implemented more efficiently using
    only one SQL query for object population.

 // test.php

// ... $q = Doctrine\_Query::create() ->from('User u')
->leftJoin('u.Phonenumbers p');

echo $q->getSqlQuery();

Lets take a look at the SQL that would be generated by the above query:

 SELECT u.id AS u**id, u.is\_active AS u**is\_active, u.is\_super\_admin
AS u**is\_super\_admin, u.first\_name AS u**first\_name, u.last\_name AS
u**last\_name, u.username AS u**username, u.password AS u**password,
u.type AS u**type, u.created\_at AS u**created\_at, u.updated\_at AS
u**updated\_at, p.id AS p**id, p.user\_id AS p**user\_id, p.phonenumber
AS p\_\_phonenumber FROM user u LEFT JOIN phonenumber p ON u.id =
p.user\_id

Now lets execute the query and play with the data:

 // test.php

// ... $users = $q->execute();

foreach($users as $user) { echo $user->username . " has phonenumbers: ";

::

    foreach($user->Phonenumbers as $phonenumber) {
        echo $phonenumber->phonenumber . "\n";
    }

}

.. CAUTION::

    Using double quotes (") in DQL strings is discouraged.
    This is sensible in MySQL standard but in DQL it can be confused as
    an identifier. Instead it is recommended to use prepared statements
    for your values and it will be escaped properly.

==============
SELECT queries
==============

``SELECT`` statement syntax:

 SELECT [ALL \| DISTINCT] , ... [FROM [WHERE ] [GROUP BY [ASC \| DESC],
... ] [HAVING ] [ORDER BY [ASC \| DESC], ...] [LIMIT OFFSET }]

The ``SELECT`` statement is used for the retrieval of data from one or
more components.

Each ``select_expr`` indicates a column or an aggregate function value
that you want to retrieve. There must be at least one ``select_expr``
in every ``SELECT`` statement.

First insert a few sample ``Account`` records:

 // test.php

// ... $account = new Account(); $account->name = 'test 1';
$account->amount = '100.00'; $account->save();

$account = new Account(); $account->name = 'test 2'; $account->amount =
'200.00'; $account->save();

Be sure to execute ``test.php``:

 $ php test.php

Now you can test the selecting of the data with these next few sample
queries:

 // test.php

// ... $q = Doctrine\_Query::create() ->select('a.name') ->from('Account
a');

echo $q->getSqlQuery();

Lets take a look at the SQL that would be generated by the above query:

 SELECT a.id AS a**id, a.name AS a**name FROM account a

 // test.php

// ... $accounts = :code:`q->execute(); print_r(`\ accounts->toArray());

The above example would produce the following output:

 $ php test.php Array ( [0] => Array ( [id] => 1 [name] => test 1
[amount] => )

::

    [1] => Array
        (
            [id] => 2
            [name] => test 2
            [amount] => 
        )

)

An asterisk can be used for selecting all columns from given component.
Even when using an asterisk the executed sql queries never actually use
it (Doctrine converts asterisk to appropriate column names, hence
leading to better performance on some databases).

 // test.php

// ... $q = Doctrine\_Query::create() ->select('a.\*') ->from('Account
a');

echo $q->getSqlQuery();

Compare the generated SQL from the last query example to the SQL
generated by the query right above:

 SELECT a.id AS a**id, a.name AS a**name, a.amount AS a\_\_amount FROM
account a

.. NOTE::

    Notice how the asterisk is replace by all the real column
    names that exist in the ``Account`` model.

Now lets execute the query and inspect the results:

 // test.php

// ... $accounts = :code:`q->execute(); print_r(`\ accounts->toArray());

The above example would produce the following output:

 $ php test.php Array ( [0] => Array ( [id] => 1 [name] => test 1
[amount] => 100.00 )

::

    [1] => Array
        (
            [id] => 2
            [name] => test 2
            [amount] => 200.00
        )

)

``FROM`` clause ``components`` indicates the component or components
from which to retrieve records.

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.username, p.\*')
->from('User u') ->leftJoin('u.Phonenumbers p')

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id, u.username AS u**username, p.id AS p**id,
p.user\_id AS p**user\_id, p.phonenumber AS p\_\_phonenumber FROM user u
LEFT JOIN phonenumber p ON u.id = p.user\_id

The ``WHERE`` clause, if given, indicates the condition or conditions
that the records must satisfy to be selected. ``where_condition`` is an
expression that evaluates to true for each row to be selected. The
statement selects all rows if there is no ``WHERE`` clause.

 // test.php

// ... $q = Doctrine\_Query::create() ->select('a.name') ->from('Account
a') ->where('a.amount > 2000');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT a.id AS a**id, a.name AS a**name FROM account a WHERE a.amount >
2000

In the ``WHERE`` clause, you can use any of the functions and operators
that DQL supports, except for aggregate (summary) functions. The
``HAVING`` clause can be used for narrowing the results with aggregate
functions:

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.username')
->from('User u') ->leftJoin('u.Phonenumbers p') ->having('COUNT(p.id) >
3');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id, u.username AS u**username FROM user u LEFT JOIN
phonenumber p ON u.id = p.user\_id HAVING COUNT(p.id) > 3

The ``ORDER BY`` clause can be used for sorting the results

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.username')
->from('User u') ->orderBy('u.username');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id, u.username AS u**username FROM user u ORDER BY
u.username

The ``LIMIT`` and ``OFFSET`` clauses can be used for efficiently
limiting the number of records to a given ``row_count``

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.username')
->from('User u') ->limit(20);

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id, u.username AS u**username FROM user u LIMIT 20

----------------
Aggregate values
----------------

Aggregate value ``SELECT`` syntax:

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.id, COUNT(t.id) AS
num\_threads') ->from('User u, u.Threads t') ->where('u.id = ?', 1)
->groupBy('u.id');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id, COUNT(f.id) AS f**0 FROM user u LEFT JOIN
forum\_\_thread f ON u.id = f.user\_id WHERE u.id = ? GROUP BY u.id

Now execute the query and inspect the results:

 // test.php

// ... $users = $q->execute();

You can easily access the ``num_threads`` data with the following code:

 // test.php

// ... echo $users->num\_threads . ' threads found';

==============
UPDATE queries
==============

``UPDATE`` statement syntax:

 UPDATE SET = , = WHERE ORDER BY LIMIT

-  The ``UPDATE`` statement updates columns of existing records in
   ``component_name`` with new values and returns the number of
   affected records.
-  The ``SET`` clause indicates which columns to modify and the values
   they should be given.
-  The optional ``WHERE`` clause specifies the conditions that identify
   which records to update. Without ``WHERE`` clause, all records are
   updated.
-  The optional ``ORDER BY`` clause specifies the order in which the
   records are being updated.
-  The ``LIMIT`` clause places a limit on the number of records that can
   be updated. You can use ``LIMIT row_count`` to restrict the scope of
   the ``UPDATE``. A ``LIMIT`` clause is a **rows-matched restriction**
   not a rows-changed restriction. The statement stops as soon as it has
   found ``record_count`` rows that satisfy the ``WHERE`` clause,
   whether or not they actually were changed.

 // test.php

// ... $q = Doctrine\_Query::create() ->update('Account')
->set('amount', 'amount + 200') ->where('id > 200');

// If you just want to set the amount to a value $q->set('amount', '?',
500);

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 UPDATE account SET amount = amount + 200 WHERE id > 200

Now to perform the update is simple. Just execute the query:

 // test.php

// ... $rows = $q->execute();

echo $rows;

==============
DELETE Queries
==============

 DELETE FROM WHERE ORDER BY LIMIT

-  The ``DELETE`` statement deletes records from ``component_name`` and
   returns the number of records deleted.
-  The optional ``WHERE`` clause specifies the conditions that identify
   which records to delete. Without ``WHERE`` clause, all records are
   deleted.
-  If the ``ORDER BY`` clause is specified, the records are deleted in
   the order that is specified.
-  The ``LIMIT`` clause places a limit on the number of rows that can be
   deleted. The statement will stop as soon as it has deleted
   ``record_count`` records.

 // test.php

// ... $q = Doctrine\_Query::create() ->delete('Account a')
->where('a.id > 3');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 DELETE FROM account WHERE id > 3

Now executing the ``DELETE`` query is just as you would think:

 // test.php

// ... $rows = $q->execute();

echo $rows;

.. NOTE::

    When executing DQL UPDATE and DELETE queries the executing
    of a query returns the number of affected rows.

===========
FROM clause
===========

Syntax:

 FROM [[LEFT \| INNER] JOIN ] ...

The ``FROM`` clause indicates the component or components from which to
retrieve records. If you name more than one component, you are
performing a join. For each table specified, you can optionally specify
an alias.

Consider the following DQL query:

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.id') ->from('User u');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u\_\_id FROM user u

Here ``User`` is the name of the class (component) and ``u`` is the
alias. You should always use short aliases, since most of the time those
make the query much shorther and also because when using for example
caching the cached form of the query takes less space when short aliases
are being used.

===========
JOIN syntax
===========

DQL JOIN Syntax:

 [[LEFT \| INNER] JOIN ] [ON \| WITH] [INDEXBY] , [[LEFT \| INNER] JOIN
] [ON \| WITH] [INDEXBY] , ... [[LEFT \| INNER] JOIN ] [ON \| WITH]
[INDEXBY]

DQL supports two kinds of joins INNER JOINs and LEFT JOINs. For each
joined component, you can optionally specify an alias.

The default join type is ``LEFT JOIN``. This join can be indicated by
the use of either ``LEFT JOIN`` clause or simply '``,``', hence the
following queries are equal:

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.id, p.id')
->from('User u') ->leftJoin('u.Phonenumbers p');

$q = Doctrine\_Query::create() ->select('u.id, p.id') ->from('User u,
u.Phonenumbers p');

echo $q->getSqlQuery();

.. tip::

    The recommended form is the first because it is more verbose
    and easier to read and understand what is being done.

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id, p.id AS p**id FROM user u LEFT JOIN phonenumber p
ON u.id = p.user\_id

.. NOTE::

    Notice how the JOIN condition is automatically added for
    you. This is because Doctrine knows how ``User`` and ``Phonenumber``
    are related so it is able to add it for you.

``INNER JOIN`` produces an intersection between two specified components
(that is, each and every record in the first component is joined to each
and every record in the second component). So basically ``INNER JOIN``
can be used when you want to efficiently fetch for example all users
which have one or more phonenumbers.

By default DQL auto-adds the primary key join condition:

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.id, p.id')
->from('User u') ->leftJoin('u.Phonenumbers p');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id, p.id AS p**id FROM User u LEFT JOIN Phonenumbers
p ON u.id = p.user\_id

----------
ON keyword
----------

If you want to override this behavior and add your own custom join
condition you can do it with the ``ON`` keyword. Consider the following
DQL query:

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.id, p.id')
->from('User u') ->leftJoin('u.Phonenumbers p ON u.id = 2');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id, p.id AS p**id FROM User u LEFT JOIN Phonenumbers
p ON u.id = 2

.. NOTE::

    Notice how the ``ON`` condition that would be normally
    automatically added is not present and the user specified condition
    is used instead.

------------
WITH keyword
------------

Most of the time you don't need to override the primary join condition,
rather you may want to add some custom conditions. This can be achieved
with the ``WITH`` keyword.

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.id, p.id')
->from('User u') ->leftJoin('u.Phonenumbers p WITH u.id = 2');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id, p.id AS p**id FROM User u LEFT JOIN Phonenumbers
p ON u.id = p.user\_id AND u.id = 2

.. NOTE::

    Notice how the ``ON`` condition isn't completely replaced.
    Instead the conditions you specify are appended on to the automatic
    condition that is added for you.

The Doctrine\_Query API offers two convenience methods for adding JOINS.
These are called ``innerJoin()`` and ``leftJoin()``, which usage should
be quite intuitive as shown below:

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.id') ->from('User u')
->leftJoin('u.Groups g') ->innerJoin('u.Phonenumbers p WITH u.id > 3')
->leftJoin('u.Email e');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u\_\_id FROM user u LEFT JOIN user\_group u2 ON u.id =
u2.user\_id LEFT JOIN groups g ON g.id = u2.group\_id INNER JOIN
phonenumber p ON u.id = p.user\_id AND u.id > 3 LEFT JOIN email e ON
u.id = e.user\_id

===============
INDEXBY keyword
===============

The ``INDEXBY`` keyword offers a way of mapping certain columns as
collection / array keys. By default Doctrine indexes multiple elements
to numerically indexed arrays / collections. The mapping starts from
zero. In order to override this behavior you need to use ``INDEXBY``
keyword as shown above:

 // test.php

// ... $q = Doctrine\_Query::create() ->from('User u INDEXBY
u.username');

$users = $q->execute();

.. NOTE::

    The ``INDEXBY`` keyword does not alter the generated SQL.
    It is simply used internally by ``Doctrine_Query`` to hydrate the
    data with the specified column as the key of each record in the
    collection.

Now the users in ``$users`` collection are accessible through their
names:

 // test.php

// ... echo $user['jack daniels']->id;

The ``INDEXBY`` keyword can be applied to any given JOIN. This means
that any given component can have each own indexing behavior. In the
following we use distinct indexing for both ``Users`` and ``Groups``.

 // test.php

// ... $q = Doctrine\_Query::create() ->from('User u INDEXBY
u.username') ->innerJoin('u.Groups g INDEXBY g.name');

$users = $q->execute();

Now lets print out the drinkers club's creation date.

 // test.php

// ... echo $users['jack daniels']->Groups['drinkers club']->createdAt;

============
WHERE clause
============

Syntax:

 WHERE

-  The ``WHERE`` clause, if given, indicates the condition or conditions
   that the records must satisfy to be selected.
-  ``where_condition`` is an expression that evaluates to true for each
   row to be selected.
-  The statement selects all rows if there is no ``WHERE`` clause.
-  When narrowing results with aggregate function values ``HAVING``
   clause should be used instead of ``WHERE`` clause

You can use the ``addWhere()``, ``andWhere()``, ``orWhere()``,
``whereIn()``, ``andWhereIn()``, ``orWhereIn()``, ``whereNotIn()``,
``andWhereNotIn()``, ``orWhereNotIn()`` functions for building complex
where conditions using ``Doctrine_Query`` objects.

Here is an example where we retrieve all active registered users or
super administrators:

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.id') ->from('User u')
->where('u.type = ?', 'registered') ->andWhere('u.is\_active = ?', 1)
->orWhere('u.is\_super\_admin = ?', 1);

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u\_\_id FROM user u WHERE u.type = ? AND u.is\_active =
? OR u.is\_super\_admin = ?

=======================
Conditional expressions
=======================

--------
Literals
--------

**Strings**

A string literal that includes a single quote is represented by two
single quotes; for example: ´´literal´s´´.

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.id, u.username')
->from('User u') ->where('u.username = ?', 'Vincent');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id, u.username AS u**username FROM user u WHERE
u.username = ?

.. NOTE::

    Because we passed the value of the ``username`` as a
    parameter to the ``where()`` method it is not included in the
    generated SQL. PDO handles the replacement when you execute the
    query. To check the parameters that exist on a ``Doctrine_Query``
    instance you can use the ``getParams()`` method.

**Integers**

Integer literals support the use of PHP integer literal syntax.

 // test.php

// ... $q = Doctrine\_Query::create() ->select('a.id') ->from('User u')
->where('u.id = 4');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u\_\_id FROM user u WHERE u.id = 4

**Floats**

Float literals support the use of PHP float literal syntax.

 // test.php

// ... $q = Doctrine\_Query::create() ->select('a.id') ->from('Account
a') ->where('a.amount = 432.123');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT a.id AS a\_\_id FROM account a WHERE a.amount = 432.123

**Booleans**

The boolean literals are true and false.

 // test.php

// ... $q = Doctrine\_Query::create() ->select('a.id') ->from('User u')
->where('u.is\_super\_admin = true');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u\_\_id FROM user u WHERE u.is\_super\_admin = 1

**Enums**

The enumerated values work in the same way as string literals.

 // test.php

// ... $q = Doctrine\_Query::create() ->select('a.id') ->from('User u')
->where("u.type = 'admin'");

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u\_\_id FROM user u WHERE u.type = 'admin'

Predefined reserved literals are case insensitive, although its a good
standard to write them in uppercase.

----------------
Input parameters
----------------

Here are some examples of using positional parameters:

**Single positional parameter:**

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.id') ->from('User u')
->where('u.username = ?', array('Arnold'));

echo $q->getSqlQuery();

.. NOTE::

    When the passed parameter for a positional parameter
    contains only one value you can simply pass a single scalar value
    instead of an array containing one value.

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u\_\_id FROM user u WHERE u.username = ?

**Multiple positional parameters:**

 // test.php

// ... $q = Doctrine\_Query::create() ->from('User u') ->where('u.id > ?
AND u.username LIKE ?', array(50, 'A%'));

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u\_\_id FROM user u WHERE (u.id > ? AND u.username LIKE
?)

Here are some examples of using named parameters:

**Single named parameter:**

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.id') ->from('User u')
->where('u.username = :name', array(':name' => 'Arnold'));

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u\_\_id FROM user u WHERE u.username = :name

**Named parameter with a LIKE statement:**

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.id') ->from('User u')
->where('u.id > :id', array(':id' => 50)) ->andWhere('u.username LIKE
:name', array(':name' => 'A%'));

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u\_\_id FROM user u WHERE u.id > :id AND u.username LIKE
:name

---------------------------------
Operators and operator precedence
---------------------------------

The operators are listed below in order of decreasing precedence.

\|\|~ Operator \|\|~ Description \|\| \|\| . \|\| Navigation operator
\|\| \|\| \|\| //Arithmetic operators: // \|\| \|\| +, - \|\| unary \|\|
\|\| \*, / \|\| multiplication and division \|\| \|\| +, - \|\| addition
and subtraction \|\| \|\| =, >, >=, <, <=, <> (not equal), \|\|
Comparison operators \|\| \|\| [NOT] LIKE, [NOT] IN, IS [NOT] NULL, IS
[NOT] EMPTY \|\| \|\| \|\| \|\| //Logical operators: // \|\| \|\| NOT
\|\| \|\| \|\| AND \|\| \|\| \|\| OR \|\| \|\|

--------------
In expressions
--------------

Syntax:

 IN (\|)

An ``IN`` conditional expression returns true if the //operand// is
found from result of the //subquery// or if its in the specificied comma
separated //value list//, hence the IN expression is always false if the
result of the subquery is empty.

When //value list// is being used there must be at least one element in
that list.

Here is an example where we use a subquery for the ``IN``:

 // test.php

// ... $q = Doctrine\_Query::create() ->from('User u') ->where('u.id IN
(SELECT u.id FROM User u INNER JOIN u.Groups g WHERE g.id = ?)', 1);

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id FROM user u WHERE u.id IN (SELECT u2.id AS u2**id
FROM user u2 INNER JOIN user\_group u3 ON u2.id = u3.user\_id INNER JOIN
groups g ON g.id = u3.group\_id WHERE g.id = ?)

Here is an example where we just use a list of integers:

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.id') ->from('User u')
->whereIn('u.id', array(1, 3, 4, 5));

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u\_\_id FROM user u WHERE u.id IN (?, ?, ?, ?)

----------------
Like Expressions
----------------

Syntax:

 string\_expression [NOT] LIKE pattern\_value [ESCAPE escape\_character]

The string\_expression must have a string value. The pattern\_value is a
string literal or a string-valued input parameter in which an underscore
(``_``) stands for any single character, a percent (``%``) character
stands for any sequence of characters (including the empty sequence),
and all other characters stand for themselves. The optional
escape\_character is a single-character string literal or a
character-valued input parameter (i.e., char or Character) and is used
to escape the special meaning of the underscore and percent characters
in ``pattern_value``.

Examples:

-  address.phone LIKE '12%3' is true for '123' '12993' and false for
   '1234'
-  asentence.word LIKE 'l\_se' is true for 'lose' and false for 'loose'
-  aword.underscored LIKE '\_%' ESCAPE '' is true for '\_foo' and false
   for 'bar'
-  address.phone NOT LIKE '12%3' is false for '123' and '12993' and true
   for '1234'

If the value of the string\_expression or pattern\_value is NULL or
unknown, the value of the LIKE expression is unknown. If the
escape\_characteris specified and is NULL, the value of the LIKE
expression is unknown.

Find all users whose email ends with '@gmail.com':

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.id') ->from('User u')
->leftJoin('u.Email e') ->where('e.address LIKE ?', '%@gmail.com');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u\_\_id FROM user u LEFT JOIN email e ON u.id =
e.user\_id WHERE e.address LIKE ?

Find all users whose name starts with letter 'A':

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.id') ->from('User u')
->where('u.username LIKE ?', 'A%');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u\_\_id FROM user u WHERE u.username LIKE ?

------------------
Exists Expressions
------------------

Syntax:

 [NOT ]EXISTS ()

The ``EXISTS`` operator returns ``TRUE`` if the subquery returns one or
more rows and ``FALSE`` otherwise.

The ``NOT EXISTS`` operator returns ``TRUE`` if the subquery returns 0
rows and ``FALSE`` otherwise.

.. NOTE::

    For the next few examples we need to add the ``ReaderLog``
    model.

 // models/ReaderLog.php

class ReaderLog extends Doctrine\_Record { public function
setTableDefinition() { $this->hasColumn('article\_id', 'integer', null,
array( 'primary' => true ) );

::

        $this->hasColumn('user_id', 'integer', null, array(
                'primary' => true
            )
        );
    }

}

Here is the same example in YAML format. You can read more about YAML in
the [doc yaml-schema-files :name] chapter:

 # schema.yml

...
===

ReaderLog: columns: article\_id: type: integer primary: true user\_id:
type: integer primary: true

.. NOTE::

    After adding the ``ReaderLog`` model don't forget to run
    the ``generate.php`` script!

 $ php generate.php

Now we can run some tests! First, finding all articles which have
readers:

 // test.php

// ... $q = Doctrine\_Query::create() ->select('a.id') ->from('Article
a') ->where('EXISTS (SELECT r.id FROM ReaderLog r WHERE r.article\_id =
a.id)');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT a.id AS a**id FROM article a WHERE EXISTS (SELECT r.id AS r**id
FROM reader\_log r WHERE r.article\_id = a.id)

Finding all articles which don't have readers:

 // test.php

// ... $q = Doctrine\_Query::create() ->select('a.id') ->from('Article
a') ->where('NOT EXISTS (SELECT r.id FROM ReaderLog r WHERE
r.article\_id = a.id));

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT a.id AS a**id FROM article a WHERE NOT EXISTS (SELECT r.id AS
r**id FROM reader\_log r WHERE r.article\_id = a.id)

-----------------------
All and Any Expressions
-----------------------

Syntax:

 operand comparison\_operator ANY (subquery) operand
comparison\_operator SOME (subquery) operand comparison\_operator ALL
(subquery)

An ALL conditional expression returns true if the comparison operation
is true for all values in the result of the subquery or the result of
the subquery is empty. An ALL conditional expression is false if the
result of the comparison is false for at least one row, and is unknown
if neither true nor false.

 $q = Doctrine\_Query::create() ->from('C') ->where('C.col1 < ALL (FROM
C2(col1))');

An ANY conditional expression returns true if the comparison operation
is true for some value in the result of the subquery. An ANY conditional
expression is false if the result of the subquery is empty or if the
comparison operation is false for every value in the result of the
subquery, and is unknown if neither true nor false.

 $q = Doctrine\_Query::create() ->from('C') ->where('C.col1 > ANY (FROM
C2(col1))');

The keyword SOME is an alias for ANY.

 $q = Doctrine\_Query::create() ->from('C') ->where('C.col1 > SOME (FROM
C2(col1))');

The comparison operators that can be used with ALL or ANY conditional
expressions are =, <, <=, >, >=, <>. The result of the subquery must be
same type with the conditional expression.

NOT IN is an alias for <> ALL. Thus, these two statements are equal:

 FROM C WHERE C.col1 <> ALL (FROM C2(col1)); FROM C WHERE C.col1 NOT IN
(FROM C2(col1));

 $q = Doctrine\_Query::create() ->from('C') ->where('C.col1 <> ALL (FROM
C2(col1))');

$q = Doctrine\_Query::create() ->from('C') ->where('C.col1 NOT IN (FROM
C2(col1))');

----------
Subqueries
----------

A subquery can contain any of the keywords or clauses that an ordinary
SELECT query can contain.

Some advantages of the subqueries:

-  They allow queries that are structured so that it is possible to
   isolate each part of a statement.
-  They provide alternative ways to perform operations that would
   otherwise require complex joins and unions.
-  They are, in many people's opinion, readable. Indeed, it was the
   innovation of subqueries that gave people the original idea of
   calling the early SQL "Structured Query Language."

Here is an example where we find all users which don't belong to the
group id 1:

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.id') ->from('User u')
->where('u.id NOT IN (SELECT u2.id FROM User u2 INNER JOIN u2.Groups g
WHERE g.id = ?)', 1);

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id FROM user u WHERE u.id NOT IN (SELECT u2.id AS
u2**id FROM user u2 INNER JOIN user\_group u3 ON u2.id = u3.user\_id
INNER JOIN groups g ON g.id = u3.group\_id WHERE g.id = ?)

Here is an example where we find all users which don't belong to any
groups

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.id') ->from('User u')
->where('u.id NOT IN (SELECT u2.id FROM User u2 INNER JOIN u2.Groups
g)');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id FROM user u WHERE u.id NOT IN (SELECT u2.id AS
u2**id FROM user u2 INNER JOIN user\_group u3 ON u2.id = u3.user\_id
INNER JOIN groups g ON g.id = u3.group\_id)

======================
Functional Expressions
======================

----------------
String functions
----------------

The //CONCAT// function returns a string that is a concatenation of its
arguments. In the example above we map the concatenation of users
``first\_name`` and ``last_name`` to a value called ``name``.

 // test.php

// ... $q = Doctrine\_Query::create() ->select('CONCAT(u.first\_name,
u.last\_name) AS name') ->from('User u');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id, CONCAT(u.first\_name, u.last\_name) AS u**0 FROM
user u

Now we can execute the query and get the mapped function value:

 $users = $q->execute();

foreach($users as $user) { // here 'name' is not a property of $user, //
its a mapped function value echo $user->name; }

The second and third arguments of the //SUBSTRING// function denote the
starting position and length of the substring to be returned. These
arguments are integers. The first position of a string is denoted by 1.
The //SUBSTRING// function returns a string.

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.username')
->from('User u') ->where("SUBSTRING(u.username, 0, 1) = 'z'");

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id, u.username AS u**username FROM user u WHERE
SUBSTRING(u.username FROM 0 FOR 1) = 'z'

.. NOTE::

    Notice how the SQL is generated with the proper
    ``SUBSTRING`` syntax for the DBMS you are using!

The //TRIM// function trims the specified character from a string. If
the character to be trimmed is not specified, it is assumed to be space
(or blank). The optional trim\_character is a single-character string
literal or a character-valued input parameter (i.e., char or
Character)[30]. If a trim specification is not provided, BOTH is
assumed. The //TRIM// function returns the trimmed string.

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.username')
->from('User u') ->where('TRIM(u.username) = ?', 'Someone');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id, u.username AS u**username FROM user u WHERE
TRIM(u.username) = ?

The //LOWER// and //UPPER// functions convert a string to lower and
upper case, respectively. They return a string.

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.username')
->from('User u') ->where("LOWER(u.username) = 'jon wage'");

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id, u.username AS u**username FROM user u WHERE
LOWER(u.username) = 'someone'

The //LOCATE// function returns the position of a given string within a
string, starting the search at a specified position. It returns the
first position at which the string was found as an integer. The first
argument is the string to be located; the second argument is the string
to be searched; the optional third argument is an integer that
represents the string position at which the search is started (by
default, the beginning of the string to be searched). The first position
in a string is denoted by 1. If the string is not found, 0 is returned.

The //LENGTH// function returns the length of the string in characters
as an integer.

--------------------
Arithmetic functions
--------------------

Availible DQL arithmetic functions:

 ABS(simple\_arithmetic\_expression)
SQRT(simple\_arithmetic\_expression) MOD(simple\_arithmetic\_expression,
simple\_arithmetic\_expression)

-  The //ABS// function returns the absolute value for given number.
-  The //SQRT// function returns the square root for given number.
-  The //MOD// function returns the modulus of first argument using the
   second argument.

==========
Subqueries
==========

------------
Introduction
------------

Doctrine allows you to use sub-dql queries in the FROM, SELECT and WHERE
statements. Below you will find examples for all the different types of
subqueries Doctrine supports.

----------------------------
Comparisons using subqueries
----------------------------

Find all the users which are not in a specific group.

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.id') ->from('User u')
->where('u.id NOT IN (SELECT u.id FROM User u INNER JOIN u.Groups g
WHERE g.id = ?)', 1);

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id FROM user u WHERE u.id NOT IN (SELECT u2.id AS
u2**id FROM user u2 INNER JOIN user\_group u3 ON u2.id = u3.user\_id
INNER JOIN groups g ON g.id = u3.group\_id WHERE g.id = ?)

Retrieve the users phonenumber in a subquery and include it in the
resultset of user information.

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.id')
->addSelect('(SELECT p.phonenumber FROM Phonenumber p WHERE p.user\_id =
u.id LIMIT 1) as phonenumber') ->from('User u');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id, (SELECT p.phonenumber AS p**phonenumber FROM
phonenumber p WHERE p.user\_id = u.id LIMIT 1) AS u\_\_0 FROM user u

========================
GROUP BY, HAVING clauses
========================

DQL GROUP BY syntax:

 GROUP BY groupby\_item {, groupby\_item}\*

DQL HAVING syntax:

 HAVING conditional\_expression

``GROUP BY`` and ``HAVING`` clauses can be used for dealing with
aggregate functions. The Following aggregate functions are available on
DQL: ``COUNT``, ``MAX``, ``MIN``, ``AVG``, ``SUM``

Selecting alphabetically first user by name.

 // test.php

// ... $q = Doctrine\_Query::create() ->select('MIN(a.amount)')
->from('Account a');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT MIN(a.amount) AS a\_\_0 FROM account a

Selecting the sum of all Account amounts.

 // test.php

// ... $q = Doctrine\_Query::create() ->select('SUM(a.amount)')
->from('Account a');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT SUM(a.amount) AS a\_\_0 FROM account a

Using an aggregate function in a statement containing no ``GROUP BY``
clause, results in grouping on all rows. In the example below we fetch
all users and the number of phonenumbers they have.

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.username')
->addSelect('COUNT(p.id) as num\_phonenumbers') ->from('User u')
->leftJoin('u.Phonenumbers p') ->groupBy('u.id');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id, u.username AS u**username, COUNT(p.id) AS p\_\_0
FROM user u LEFT JOIN phonenumber p ON u.id = p.user\_id GROUP BY u.id

The ``HAVING`` clause can be used for narrowing the results using
aggregate values. In the following example we fetch all users which have
at least 2 phonenumbers

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.username')
->addSelect('COUNT(p.id) as num\_phonenumbers') ->from('User u')
->leftJoin('u.Phonenumbers p') ->groupBy('u.id')
->having('num\_phonenumbers >= 2');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id, u.username AS u**username, COUNT(p.id) AS p**0
FROM user u LEFT JOIN phonenumber p ON u.id = p.user\_id GROUP BY u.id
HAVING p**0 >= 2

You can access the number of phonenumbers with the following code:

 // test.php

// ... $users = $q->execute();

foreach($users as $user) { echo $user->name . ' has ' .
$user->num\_phonenumbers . ' phonenumbers'; }

===============
ORDER BY clause
===============

------------
Introduction
------------

Record collections can be sorted efficiently at the database level using
the ORDER BY clause.

Syntax:

 [ORDER BY {ComponentAlias.columnName} [ASC \| DESC], ...]

Examples:

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.username')
->from('User u') ->leftJoin('u.Phonenumbers p') ->orderBy('u.username,
p.phonenumber');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id, u.username AS u**username FROM user u LEFT JOIN
phonenumber p ON u.id = p.user\_id ORDER BY u.username, p.phonenumber

In order to sort in reverse order you can add the ``DESC`` (descending)
keyword to the name of the column in the ``ORDER BY`` clause that you
are sorting by. The default is ascending order; this can be specified
explicitly using the ``ASC`` keyword.

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.username')
->from('User u') ->leftJoin('u.Email e') ->orderBy('e.address DESC, u.id
ASC');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id, u.username AS u**username FROM user u LEFT JOIN
email e ON u.id = e.user\_id ORDER BY e.address DESC, u.id ASC

-----------------------------
Sorting by an aggregate value
-----------------------------

In the following example we fetch all users and sort those users by the
number of phonenumbers they have.

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.username, COUNT(p.id)
count') ->from('User u') ->innerJoin('u.Phonenumbers p')
->orderby('count');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id, u.username AS u**username, COUNT(p.id) AS p**0
FROM user u INNER JOIN phonenumber p ON u.id = p.user\_id ORDER BY p**0

------------------
Using random order
------------------

In the following example we use random in the ``ORDER BY`` clause in
order to fetch random post.

 // test.php

// ... $q = Doctrine\_Query::create() ->select('t.id, RANDOM() AS rand')
->from('Forum\_Thread t') ->orderby('rand') ->limit(1);

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT f.id AS f**id, RAND() AS f**0 FROM forum**thread f ORDER BY f**0
LIMIT 1

========================
LIMIT and OFFSET clauses
========================

Propably the most complex feature DQL parser has to offer is its
``LIMIT`` clause parser. Not only does the DQL ``LIMIT`` clause parser
take care of ``LIMIT`` database portability it is capable of limiting
the number of records instead of rows by using complex query analysis
and subqueries.

Retrieve the first 20 users and all their associated phonenumbers:

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.username,
p.phonenumber') ->from('User u') ->leftJoin('u.Phonenumbers p')
->limit(20);

echo $q->getSqlQuery();

.. tip::

    You can also use the ``offset()`` method of the
    ``Doctrine_Query`` object in combination with the ``limit()``
    method to produce your desired ``LIMIT`` and ``OFFSET`` in the
    executed SQL query.

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id, u.username AS u**username, p.id AS p**id,
p.phonenumber AS p**phonenumber FROM user u LEFT JOIN phonenumber p ON
u.id = p.user\_id LIMIT 20

------------------
Driver Portability
------------------

DQL ``LIMIT`` clause is portable on all supported databases. Special
attention have been paid to following facts:

-  Only Mysql, Pgsql and Sqlite implement LIMIT / OFFSET clauses
   natively
-  In Oracle / Mssql / Firebird LIMIT / OFFSET clauses need to be
   emulated in driver specific way
-  The limit-subquery-algorithm needs to execute to subquery separately
   in mysql, since mysql doesn't yet support LIMIT clause in subqueries
-  Pgsql needs the order by fields to be preserved in SELECT clause,
   hence limit-subquery-algorithm needs to take this into consideration
   when pgsql driver is used
-  Oracle only allows < 30 object identifiers (= table/column
   names/aliases), hence the limit subquery must use as short aliases as
   possible and it must avoid alias collisions with the main query.

----------------------------
The limit-subquery-algorithm
----------------------------

The limit-subquery-algorithm is an algorithm that DQL parser uses
internally when one-to-many / many-to-many relational data is being
fetched simultaneously. This kind of special algorithm is needed for the
LIMIT clause to limit the number of records instead of sql result set
rows.

This behavior can be overwritten using the configuration system (at
global, connection or table level) using:

 $table->setAttribute(Doctrine\_Core::ATTR\_QUERY\_LIMIT,
Doctrine\_Core::LIMIT\_ROWS);
$table->setAttribute(Doctrine\_Core::ATTR\_QUERY\_LIMIT,
Doctrine\_Core::LIMIT\_RECORDS); // revert

In the following example we have users and phonenumbers with their
relation being one-to-many. Now lets say we want fetch the first 20
users and all their related phonenumbers.

Now one might consider that adding a simple driver specific LIMIT 20 at
the end of query would return the correct results. Thats wrong, since we
you might get anything between 1-20 users as the first user might have
20 phonenumbers and then record set would consist of 20 rows.

DQL overcomes this problem with subqueries and with complex but
efficient subquery analysis. In the next example we are going to fetch
first 20 users and all their phonenumbers with single efficient query.
Notice how the DQL parser is smart enough to use column aggregation
inheritance even in the subquery and how it's smart enough to use
different aliases for the tables in the subquery to avoid alias
collisions.

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.id, u.username, p.\*')
->from('User u') ->leftJoin('u.Phonenumbers p') ->limit(20);

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id, u.username AS u**username, p.id AS p**id,
p.phonenumber AS p**phonenumber, p.user\_id AS p\_\_user\_id FROM user u
LEFT JOIN phonenumber p ON u.id = p.user\_id WHERE u.id IN (SELECT
DISTINCT u2.id FROM user u2 LIMIT 20)

.. NOTE::

    Notice how the IN clause with the subquery was added. This
    is so that the users are limited to 20 and the users phonenumbers
    are not limited.

In the next example we are going to fetch first 20 users and all their
phonenumbers and only those users that actually have phonenumbers with
single efficient query, hence we use an ``INNER JOIN``. Notice how the
DQL parser is smart enough to use the ``INNER JOIN`` in the subquery:

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.id, u.username, p.\*')
->from('User u') ->innerJoin('u.Phonenumbers p') ->limit(20);

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id, u.username AS u**username, p.id AS p**id,
p.phonenumber AS p**phonenumber, p.user\_id AS p\_\_user\_id FROM user u
INNER JOIN phonenumber p ON u.id = p.user\_id WHERE u.id IN (SELECT
DISTINCT u2.id FROM user u2 INNER JOIN phonenumber p2 ON u2.id =
p2.user\_id LIMIT 20)

=============
Named Queries
=============

When you are dealing with a model that may change, but you need to keep
your queries easily updated, you need to find an easy way to define
queries. Imagine for example that you change one field and you need to
follow all queries in your application to make sure it'll not break
anything.

Named Queries is a nice and effective way to solve this situation,
allowing you to create ``Doctrine_Queries`` and reuse them without the
need to keep rewritting them.

The Named Query support is built at the top of
``Doctrine\_Query\_Registry`` support. ``Doctrine\_Query_Registry`` is
a class for registering and naming queries. It helps with the
organization of your applications queries and along with that it offers
some very nice convenience stuff.

The queries are added using the ``add()`` method of the registry object.
It takes two parameters, the query name and the actual DQL query.

 // test.php

// ... $r = Doctrine\_Manager::getInstance()->getQueryRegistry();

$r->add('User/all', 'FROM User u');

$userTable = Doctrine\_Core::getTable('User');

// find all users $users = $userTable->find('all');

To simplify this support, ``Doctrine_Table`` support some accessors to
``Doctrine\_Query_Registry``.

----------------------
Creating a Named Query
----------------------

When you build your models with option ``generateTableClasses`` defined
as true, each record class will also generate a ``\*Table`` class,
extending from ``Doctrine_Table``.

Then, you can implement the method ``construct()`` to include your Named
Queries:

 class UserTable extends Doctrine\_Table { public function construct() {
// Named Query defined using DQL string
$this->addNamedQuery('get.by.id', 'SELECT u.username FROM User u WHERE
u.id = ?');

::

        // Named Query defined using Doctrine_Query object
        $this->addNamedQuery(
            'get.by.similar.usernames', Doctrine_Query::create()
                ->select('u.id, u.username')
                ->from('User u')
                ->where('LOWER(u.username) LIKE LOWER(?)')
        );
    }

}

---------------------
Accessing Named Query
---------------------

To reach the ``MyFooTable`` class, which is a subclass of
``Doctrine_Table``, you can do the following:

 $userTable = Doctrine\_Core::getTable('User');

To access the Named Query (will return you a ``Doctrine_Query``
instance, always):

 $q = $userTable->createNamedQuery('get.by.id');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u**id, u.username AS u**username FROM user u WHERE u.id
= ?

-----------------------
Executing a Named Query
-----------------------

There are two ways to execute a Named Query. The first one is by
retrieving the ``Doctrine_Query`` and then executing it normally, as a
normal instance:

 // test.php

// ... $users = Doctrine\_Core::getTable('User')
->createNamedQuery('get.by.similar.usernames')
->execute(array('%jon%wage%'));

You can also simplify the execution, by doing:

 // test.php

// ... $users = Doctrine\_Core::getTable('User')
->find('get.by.similar.usernames', array('%jon%wage%'));

The method ``find()`` also accepts a third parameter, which is the
hydration mode.

---------------------------
Cross-Accessing Named Query
---------------------------

If that's not enough, Doctrine take advantage the
``Doctrine\_Query_Registry`` and uses namespace queries to enable
cross-access of Named Queries between objects. Suppose you have the
``\*Table`` class instance of record ``Article``. You want to call the
"get.by.id" Named Query of record ``User``. To access the Named Query,
you have to do:

 // test.php

// ... $articleTable = Doctrine\_Core::getTable('Article');

$users = $articleTable->find('User/get.by.id', array(1, 2, 3));

===
BNF
===

 QL\_statement ::= select\_statement \| update\_statement \|
delete\_statement select\_statement ::= select\_clause from\_clause
[where\_clause] [groupby\_clause] [having\_clause] [orderby\_clause]
update\_statement ::= update\_clause [where\_clause] delete\_statement
::= delete\_clause [where\_clause] from\_clause ::= FROM
identification\_variable\_declaration {,
{identification\_variable\_declaration \|
collection\_member\_declaration``\*
identification\_variable\_declaration ::= range\_variable\_declaration {
join \| fetch\_join }\* range\_variable\_declaration ::=
abstract\_schema\_name [AS ] identification\_variable join ::=
join\_spec join\_association\_path\_expression [AS ]
identification\_variable fetch\_join ::= join\_specFETCH
join\_association\_path\_expression association\_path\_expression ::=
collection\_valued\_path\_expression \|
single\_valued\_association\_path\_expression join\_spec::= [LEFT [OUTER
] \|INNER ]JOIN join\_association\_path\_expression ::=
join\_collection\_valued\_path\_expression \|
join\_single\_valued\_association\_path\_expression
join\_collection\_valued\_path\_expression::=
identification\_variable.collection\_valued\_association\_field
join\_single\_valued\_association\_path\_expression::=
identification\_variable.single\_valued\_association\_field
collection\_member\_declaration ::= IN (
collection\_valued\_path\_expression) [AS ] identification\_variable
single\_valued\_path\_expression ::= state\_field\_path\_expression \|
single\_valued\_association\_path\_expression
state\_field\_path\_expression ::= {identification\_variable \|
single\_valued\_association\_path\_expression}.state\_field
single\_valued\_association\_path\_expression ::=
identification\_variable.{single\_valued\_association\_field.}\*
single\_valued\_association\_field collection\_valued\_path\_expression
::=
identification\_variable.{single\_valued\_association\_field.}*collection\_valued\_association\_field
state\_field ::= {embedded\_class\_state\_field.}*simple\_state\_field
update\_clause ::=UPDATE abstract\_schema\_name [[AS ]
identification\_variable] SET update\_item {, update\_item}\*
update\_item ::= [identification\_variable.]{state\_field \|
single\_valued\_association\_field} = new\_value new\_value ::=
simple\_arithmetic\_expression \| string\_primary \| datetime\_primary
\|

boolean\_primary \| enum\_primary simple\_entity\_expression \| NULL
delete\_clause ::=DELETE FROM abstract\_schema\_name [[AS ]
identification\_variable] select\_clause ::=SELECT [DISTINCT ]
select\_expression {, select\_expression}\* select\_expression ::=
single\_valued\_path\_expression \| aggregate\_expression \|
identification\_variable \| OBJECT( identification\_variable) \|
constructor\_expression constructor\_expression ::= NEW
constructor\_name( constructor\_item {, constructor\_item}*)
constructor\_item ::= single\_valued\_path\_expression \|
aggregate\_expression aggregate\_expression ::= {AVG \|MAX \|MIN \|SUM
}( [DISTINCT ] state\_field\_path\_expression) \| COUNT ( [DISTINCT ]
identification\_variable \| state\_field\_path\_expression \|
single\_valued\_association\_path\_expression) where\_clause ::=WHERE
conditional\_expression groupby\_clause ::=GROUP BY groupby\_item {,
groupby\_item}* groupby\_item ::= single\_valued\_path\_expression \|
identification\_variable having\_clause ::=HAVING
conditional\_expression orderby\_clause ::=ORDER BY orderby\_item {,
orderby\_item}\* orderby\_item ::= state\_field\_path\_expression [ASC
\|DESC ] subquery ::= simple\_select\_clause subquery\_from\_clause
[where\_clause] [groupby\_clause] [having\_clause]
subquery\_from\_clause ::= FROM
subselect\_identification\_variable\_declaration {,
subselect\_identification\_variable\_declaration}\*
subselect\_identification\_variable\_declaration ::=
identification\_variable\_declaration \| association\_path\_expression
[AS ] identification\_variable \| collection\_member\_declaration
simple\_select\_clause ::=SELECT [DISTINCT ] simple\_select\_expression
simple\_select\_expression::= single\_valued\_path\_expression \|
aggregate\_expression \| identification\_variable
conditional\_expression ::= conditional\_term \|
conditional\_expressionOR conditional\_term conditional\_term ::=
conditional\_factor \| conditional\_termAND conditional\_factor
conditional\_factor ::= [NOT ] conditional\_primary conditional\_primary
::= simple\_cond\_expression \|( conditional\_expression)
simple\_cond\_expression ::= comparison\_expression \|
between\_expression \| like\_expression \| in\_expression \|
null\_comparison\_expression \|
empty\_collection\_comparison\_expression \|

collection\_member\_expression \| exists\_expression between\_expression
::= arithmetic\_expression [NOT ]BETWEEN arithmetic\_expressionAND
arithmetic\_expression \| string\_expression [NOT ]BETWEEN
string\_expressionAND string\_expression \| datetime\_expression [NOT
]BETWEEN datetime\_expressionAND datetime\_expression in\_expression ::=
state\_field\_path\_expression [NOT ]IN ( in\_item {, in\_item}\* \|
subquery) in\_item ::= literal \| input\_parameter like\_expression ::=
string\_expression [NOT ]LIKE pattern\_value [ESCAPE escape\_character]
null\_comparison\_expression ::= {single\_valued\_path\_expression \|
input\_parameter}IS [NOT ] NULL
empty\_collection\_comparison\_expression ::=
collection\_valued\_path\_expressionIS [NOT] EMPTY
collection\_member\_expression ::= entity\_expression [NOT ]MEMBER [OF ]
collection\_valued\_path\_expression exists\_expression::= [NOT ]EXISTS
(subquery) all\_or\_any\_expression ::= {ALL \|ANY \|SOME } (subquery)
comparison\_expression ::= string\_expression comparison\_operator
{string\_expression \| all\_or\_any\_expression} \| boolean\_expression
{= \|<> } {boolean\_expression \| all\_or\_any\_expression} \|
enum\_expression {= \|<> } {enum\_expression \|
all\_or\_any\_expression} \| datetime\_expression comparison\_operator
{datetime\_expression \| all\_or\_any\_expression} \| entity\_expression
{= \|<> } {entity\_expression \| all\_or\_any\_expression} \|
arithmetic\_expression comparison\_operator {arithmetic\_expression \|
all\_or\_any\_expression} comparison\_operator ::== \|> \|>= \|< \|<=
\|<> arithmetic\_expression ::= simple\_arithmetic\_expression \|
(subquery) simple\_arithmetic\_expression ::= arithmetic\_term \|
simple\_arithmetic\_expression {+ \|- } arithmetic\_term
arithmetic\_term ::= arithmetic\_factor \| arithmetic\_term {\* \|/ }
arithmetic\_factor arithmetic\_factor ::= [{+ \|- }] arithmetic\_primary
arithmetic\_primary ::= state\_field\_path\_expression \|
numeric\_literal \| (simple\_arithmetic\_expression) \| input\_parameter
\| functions\_returning\_numerics \| aggregate\_expression
string\_expression ::= string\_primary \| (subquery) string\_primary ::=
state\_field\_path\_expression \| string\_literal \| input\_parameter \|
functions\_returning\_strings \| aggregate\_expression

datetime\_expression ::= datetime\_primary \| (subquery)
datetime\_primary ::= state\_field\_path\_expression \| input\_parameter
\| functions\_returning\_datetime \| aggregate\_expression
boolean\_expression ::= boolean\_primary \| (subquery) boolean\_primary
::= state\_field\_path\_expression \| boolean\_literal \|
input\_parameter \| enum\_expression ::= enum\_primary \| (subquery)
enum\_primary ::= state\_field\_path\_expression \| enum\_literal \|
input\_parameter \| entity\_expression ::=
single\_valued\_association\_path\_expression \|
simple\_entity\_expression simple\_entity\_expression ::=
identification\_variable \| input\_parameter
functions\_returning\_numerics::= LENGTH( string\_primary) \| LOCATE(
string\_primary, string\_primary[, simple\_arithmetic\_expression]) \|
ABS( simple\_arithmetic\_expression) \| SQRT(
simple\_arithmetic\_expression) \| MOD( simple\_arithmetic\_expression,
simple\_arithmetic\_expression) \| SIZE(
collection\_valued\_path\_expression) functions\_returning\_datetime ::=
CURRENT\_DATE \| CURRENT\_TIME \| CURRENT\_TIMESTAMP
functions\_returning\_strings ::= CONCAT( string\_primary,
string\_primary) \| SUBSTRING( string\_primary,
simple\_arithmetic\_expression, simple\_arithmetic\_expression)\| TRIM(
[[trim\_specification] [trim\_character]FROM ] string\_primary) \|
LOWER( string\_primary) \| UPPER( string\_primary) trim\_specification
::=LEADING \| TRAILING \| BOTH

=============
Magic Finders
=============

Doctrine offers some magic finders for your Doctrine models that allow
you to find a record by any column that is present in the model. This is
helpful for simply finding a user by their username, or finding a group
by the name of it. Normally this would require writing a
``Doctrine_Query`` instance and storing this somewhere so it can be
reused. That is no longer needed for simple situations like that.

The basic pattern for the finder methods are as follows:
``findBy%s(:code:`value)`` or ``findOneBy%s(`\ value)``. The ``%s`` can
be a column name or a relation alias. If you give a column name you must
give the value you are looking for. If you specify a relationship alias,
you can either pass an instance of the relation class to find, or give
the actual primary key value.

First lets retrieve the ``UserTable`` instance to work with:

 // test.php

// ... $userTable = Doctrine\_Core::getTable('User');

Now we can easily find a ``User`` record by its primary key by using the
``find()`` method:

 // test.php

// ... $user = $userTable->find(1);

Now if you want to find a single user by their username you can use the
following magic finder:

 // test.php

// ... $user = $userTable->findOneByUsername('jonwage');

You can also easily find records by using the relationships between
records. Because ``User`` has many ``Phonenumbers`` we can find those
``Phonenumbers`` by passing the ``findBy\*\*()`` method a ``User``
instance:

 // test.php

// ... $phonenumberTable = Doctrine\_Core::getTable('Phonenumber');

$phonenumbers = :code:`phonenumberTable->findByUser(`\ user);

The magic finders will even allow a little more complex finds. You can
use the ``And`` and ``Or`` keywords in the method name to retrieve
record by multiple properties.

 $user = $userTable->findOneByUsernameAndPassword('jonwage',
md5('changeme'));

You can even mix the conditions.

 $users = $userTable->findByIsAdminAndIsModeratorOrIsSuperAdmin(true,
true, true);

.. CAUTION::

    These are very limited magic finders and it is always
    recommended to expand your queries to be manually written DQL
    queries. These methods are meant for only quickly accessing single
    records, no relationships, and are good for prototyping code
    quickly.

.. note::

    The documented magic finders above are made possibly by
    using PHP's ``[http://us3.php.net/\__call **call()]`` overloading
    functionality. The undefined functions are forwarded to
    ``Doctrine\_Table::**call()`` where the ``Doctrine_Query`` objects
    are built, executed and returned to the user.

=================
Debugging Queries
=================

The ``Doctrine_Query`` object has a few functions that can be used to
help debug problems with the query:

Sometimes you may want to see the complete SQL string of your
``Doctrine_Query`` object:

 // test.php

// ... $q = Doctrine\_Query::create() ->select('u.id') ->from('User u')
->orderBy('u.username');

echo $q->getSqlQuery();

The above call to ``getSql()`` would output the following SQL query:

 SELECT u.id AS u\_\_id FROM user u ORDER BY u.username

.. NOTE::

    The SQL returned above by the ``Doctrine_Query::getSql()``
    function does not replace the tokens with the parameters. This is
    the job of PDO and when we execute the query we pass the parameters
    to PDO where the replacement is executed. You can retrieve the array
    of parameters with the ``Doctrine_Query::getParams()`` method.

Get the array of parameters for the ``Doctrine_Query`` instance:

 // test.php

// ... print\_r($q->getParams());

==========
Conclusion
==========

The Doctrine Query Language is by far one of the most advanced and
helpful feature of Doctrine. It allows you to easily select very complex
data from RDBMS relationships efficiently!

Now that we have gone over most of the major components of Doctrine and
how to use them we are going to take a step back in the next chapter and
look at everything from a birds eye view in the [doc component-overview
:name] chapter.
